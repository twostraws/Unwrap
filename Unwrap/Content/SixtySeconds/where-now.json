{
    "title": "Final test",
    "postscript": "You can go back and re-read any of these chapters whenever you want \u2013 keep your Swift skills fresh!",
    "reviewType": "multipleSelection",
    "question": "Which of these statements are true?",
    "hint": "These questions are taken from a variety of chapters \u2013 you might need to re-read one of them if you're not sure about an answer.",
    "syntaxHighlighting": false,
    "correct": [
        {
            "answer": "Strings are case-sensitive.",
            "reason": "This is correct."
        },
        {
            "answer": "Closures can capture values around them.",
            "reason": "This is correct."
        },
        {
            "answer": "Structs are copied differently from classes.",
            "reason": "This is correct."
        },
        {
            "answer": "Enums can have associated values.",
            "reason": "This is correct."
        },
        {
            "answer": "Variadic functions take any number of parameters.",
            "reason": "This is correct."
        },
        {
            "answer": "Throwing functions must be called using <code>try<\/code>.",
            "reason": "This is correct."
        }
    ],
    "wrong": [
        {
            "answer": "Functions inside structs are called closures.",
            "reason": "They are called methods."
        },
        {
            "answer": "Swift automatically generates the shorthand parameter names <code>#0<\/code>, <code>#1<\/code>, and so on.",
            "reason": "They are named <code>$0<\/code> rather than <code>#0<\/code>."
        },
        {
            "answer": "Classes may not contain private methods.",
            "reason": "Classes are perfectly able to contain private methods."
        },
        {
            "answer": "You can make a new struct by inheriting from any other structs that are not declared using <code>final<\/code>.",
            "reason": "Structs cannot use inheritance."
        },
        {
            "answer": "Extensions can only be used on protocols.",
            "reason": "You can also extend specific types."
        },
        {
            "answer": "<code>String<\/code> and <code>String!<\/code> are the same thing.",
            "reason": "Implicitly unwrapped optionals such as <code>String!<\/code> might be nil."
        }
    ]
}